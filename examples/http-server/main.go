/*
 * Copyright (c) CERN 2017
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"flag"
	"fmt"
	"github.com/Sirupsen/logrus"
	"gitlab.cern.ch/flutter/go-proxy"
	"math/big"
	mrand "math/rand"
	"net"
	"net/http"
	"os"
	"time"
)

var listenAddr = flag.String("listen", ":8443", "Ip and port to bind to")
var hostName = flag.String("hostname", "", "Hostname")
var caPath = flag.String("capath", "/etc/grid-security/certificates", "CA Path")
var loadCrls = flag.Bool("crls", false, "Enable CRLs")
var vomsDir = flag.String("vomsdir", "/etc/grid-security/vomsdir", "VOMS dir")

func handler(w http.ResponseWriter, req *http.Request) {
	var err error
	logrus.Info("Got request")

	w.Header().Set("Content-Type", "text/plain")
	fmt.Fprint(w, "Hello there\n")

	if req.TLS.PeerCertificates == nil {
		logrus.Warn("Missing client certificate")
		return
	}

	x509 := proxy.X509Proxy{}
	if err = x509.InitFromCertificates(req.TLS.PeerCertificates); err != nil {
		logrus.Error(err)
		return
	}

	fmt.Fprint(w, "You are ", proxy.NameRepr(&x509.Subject), "\n")
	for _, voms := range x509.VomsAttributes {
		fmt.Fprint(w, "Role ", voms.Fqan, " (", voms.Vo, ")\n")
	}
	fmt.Fprint(w, "Delegation ID ", x509.DelegationID(), "\n")

	verifyOptions := proxy.VerifyOptions{
		VomsDir:     *vomsDir,
		CurrentTime: time.Now(),
	}
	if verifyOptions.Roots, err = proxy.LoadCAPath(*caPath, *loadCrls); err != nil {
		logrus.Error("Failed to load the CA Path: ", err)
		return
	}

	if err := x509.Verify(verifyOptions); err != nil {
		fmt.Fprint(w, "Your proxy doesn't seem valid: ", err, "\n")
	} else {
		fmt.Fprint(w, "Your proxy seems valid\n")
	}
}

func generateCertificate(hostname string) (cert tls.Certificate, err error) {
	subject := pkix.Name{
		CommonName: hostname,
	}

	rsaKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return
	}

	template := x509.Certificate{
		Subject:      subject,
		SerialNumber: big.NewInt(mrand.Int63()),
		NotBefore:    time.Now().Add(-time.Minute),
		NotAfter:     time.Now().Add(24 * 30 * time.Hour),
		IsCA:         false,
	}
	raw, err := x509.CreateCertificate(rand.Reader, &template, &template, &rsaKey.PublicKey, rsaKey)
	if err != nil {
		return
	}
	cert.Certificate = [][]byte{raw}
	cert.PrivateKey = rsaKey
	cert.Leaf, err = x509.ParseCertificate(raw)
	return
}

func getProxyPath() string {
	if path := os.Getenv("X509_USER_PROXY"); path != "" {
		return path
	}

	return fmt.Sprintf("/tmp/x509up_u%d", os.Getuid())
}

func main() {
	var err error

	flag.Parse()
	logrus.SetLevel(logrus.DebugLevel)

	if *hostName == "" {
		if *hostName, err = os.Hostname(); err != nil {
			logrus.Fatal(err)
		}
	}

	cert, err := generateCertificate(*hostName)
	if err != nil {
		logrus.Fatal(err)
	}

	logrus.WithField("bits", cert.PrivateKey.(*rsa.PrivateKey).N.BitLen()).
		Debug("Using autogenerated certificate with subject ", proxy.NameRepr(&cert.Leaf.Subject))

	http.HandleFunc("/", handler)

	server := &http.Server{
		Addr:    *listenAddr,
		Handler: nil,
		TLSConfig: &tls.Config{
			ClientAuth:   tls.RequireAnyClientCert,
			Certificates: []tls.Certificate{cert},
		},
	}

	ln, err := net.Listen("tcp", server.Addr)
	if err != nil {
		logrus.Fatal(err)
	}
	logrus.Info("Listening on ", server.Addr)
	logrus.Info("To test the service, run")
	logrus.Info("curl -k https://localhost:", ln.Addr().(*net.TCPAddr).Port, " -E ", getProxyPath())

	tlsListener := tls.NewListener(ln, server.TLSConfig)
	logrus.Fatal(server.Serve(tlsListener))
}
